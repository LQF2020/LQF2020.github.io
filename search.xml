<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DigitalOcean, Node.js, Nginx, PM2整合部署方案</title>
    <url>/post/digitalocean-node-js-nginx-pm2%E6%95%B4%E5%90%88%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88.html</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>通过阅读本教程，你将会学习如何将 Node.js 应用部署到云端服务器 DigitalOcean 中，并整合 SSH 登录， Nginx 作为反向代理，PM2 进程管理器， 防火墙端口配置的相关知识。</p>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ol>
<li>为需要部署的网站购买自定义域名。尚未拥有域名，可前往 <a href="https://sg.godaddy.com/zh">GoDaddy</a> 或者 其他域名提供商注册。</li>
<li>本地创建 SSH 连接的公私钥。尚未拥有公钥，前往 <a href="/post/ssh%E5%85%AC%E9%92%A5%E5%88%9B%E5%BB%BA%E6%95%99%E7%A8%8B.html" title="SSH公钥创建">SSH公钥创建</a> 教程。</li>
<li>创建网站部署的云服务器（VPS）。本教程使用 DigitalOcean 创建。尚未拥有 VPS, 前往 <a href="/post/%E5%88%9B%E5%BB%BAdigitalocean%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E4%BE%8Bdroplet.html" title="DigitalOcean服务器创建">DigitalOcean服务器创建</a> 教程。</li>
</ol>
<h2 id="教程用例"><a href="#教程用例" class="headerlink" title="教程用例"></a>教程用例</h2><ul>
<li>GoDaddy 创建的网站域名：demo.luqifu.tech ( 仅供教程使用 )</li>
<li>DigitalOcean 服务器【Ubuntu18.04.3】 IP: 161.35.59.204 ( 仅供教程使用 )</li>
</ul>
<h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2><ol>
<li>使用 SSH public key 远程登录 DigitalOcean 云服务器</li>
<li>创建 Node.js 应用，WEB 框架为 Express.js</li>
<li>安装 Node 应用管理器 PM2，并且后台运行 Express.js</li>
<li>DNS 域名和服务器 IP 绑定</li>
<li>Nginx 下载，进行反向代理配置</li>
</ol>
<h3 id="（一）使用-SSH-public-key-远程登录-DigitalOcean-云服务器"><a href="#（一）使用-SSH-public-key-远程登录-DigitalOcean-云服务器" class="headerlink" title="（一）使用 SSH public key 远程登录 DigitalOcean 云服务器"></a><strong>（一）使用 SSH public key 远程登录 DigitalOcean 云服务器</strong></h3><p>本地控制台输入</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">ssh root@xxx.xxx.xxx.xxx <span class="comment"># 这里，我输入 ssh root@161.35.59.204</span></span><br></pre></td></tr></tbody></table></figure>

<p>登陆方式有两种，密码登录 和 SSH keys 登录，我们更推荐后者，后者更方便和安全。<br>如何创建属于您的 SSH 公钥对，请参考教程 <a href="/post/ssh%E5%85%AC%E9%92%A5%E5%88%9B%E5%BB%BA%E6%95%99%E7%A8%8B.html" title="SSH公钥创建">SSH公钥创建</a>。</p>
<p>成功登录后，界面如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">ssh root@161.35.59.204</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">Last login: Wed Aug 12 01:57:51 2020</span><br><span class="line">root@my-node-server:~#</span><br></pre></td></tr></tbody></table></figure>

<h3 id="（二）创建-Node-js-应用，教程使用-WEB-框架为-Express-js"><a href="#（二）创建-Node-js-应用，教程使用-WEB-框架为-Express-js" class="headerlink" title="（二）创建 Node.js 应用，教程使用 WEB 框架为 Express.js"></a><strong>（二）创建 Node.js 应用，教程使用 WEB 框架为 Express.js</strong></h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 成功登录您的服务器后，请执行：</span><br><span class="line"># 注意：本教程使用Ubuntu的apt安装工具包，请选择适合您OS的包安装工具：</span><br><span class="line"></span><br><span class="line">sudo apt-get update      # 更新服务器的软件库</span><br><span class="line">sudo apt-get upgrade     # 更新服务器的软件包</span><br><span class="line"></span><br><span class="line">sudo apt-get install nodejs   # 安装node包</span><br><span class="line">sudo apt-get install npm      # 安装npm包</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 检查上述包是否安装成功</span><br><span class="line"></span><br><span class="line">node -v</span><br><span class="line"># v8.10.0 版本号</span><br><span class="line"></span><br><span class="line">npm -v</span><br><span class="line"># 3.5.2 版本号</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">cd ~                         # 进入当前用户目录</span><br><span class="line">mkdir HelloWorld             # 创建名为 HelloWorld的文件夹</span><br><span class="line">cd HelloWorld                # 进入HelloWorld文件夹目录下</span><br><span class="line">npm init                     # 初始化npm库</span><br><span class="line">npm install express --save   # 安装express依赖</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 创建 app.js 文件，实现一个基于 Express 简单的 http 服务器，端口为 3000。</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span></span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> {</span><br><span class="line">res.send(<span class="string">'Hello World!'</span>)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">app.listen(port, <span class="function">() =&gt;</span> {</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Example app listening at http://localhost:<span class="subst">${port}</span>`</span>)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">node app.js               # 运行 app.js</span><br></pre></td></tr></tbody></table></figure>

<p>最后，在任意浏览器输入 http://{ 您的服务器 IP }:3000/ ， 即可看到 “Hello World” !</p>
<p>恭喜！到这一步， 你可以通过浏览器访问 服务器 IP 地址，获取基于 Node 创建的 HelloWorld 应用页面 !</p>
<h3 id="（三）安装-Node-应用管理器-PM2，并且后台运行-Express-js"><a href="#（三）安装-Node-应用管理器-PM2，并且后台运行-Express-js" class="headerlink" title="（三）安装 Node 应用管理器 PM2，并且后台运行 Express.js"></a><strong>（三）安装 Node 应用管理器 PM2，并且后台运行 Express.js</strong></h3><p>使用 PM2 好处：可以后台持续运行 node.js 应用，不用担心服务器重启导致网站关闭。它允许创建,管理和销毁多个 Node.js 应用实例。</p>
<p>PM2 官网：<a href="https://pm2.keymetrics.io/">https://pm2.keymetrics.io/</a></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">npm install pm2 -g        # 在服务器进行 PM2 全局安装</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">cd ~/HelloWorld/                       # 进入项目目录下</span><br><span class="line">pm2 start app.js --name Helloworld     # PM2 运行 node.js 应用</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 通过执行下列命令，可保证云服务器开机后，pm2管理器自动运行Node.js应用</span><br><span class="line"></span><br><span class="line"># 查看当前所有被pm2管理的应用列表</span><br><span class="line">pm2 list</span><br><span class="line"></span><br><span class="line"># 将当前列表中的所有应用永久储存在pm2中</span><br><span class="line">pm2 save</span><br><span class="line"></span><br><span class="line"># 将pm2配置成系统开启服务</span><br><span class="line">pm2 startup</span><br></pre></td></tr></tbody></table></figure>

<h3 id="（四）DNS-域名和服务器-IP-绑定"><a href="#（四）DNS-域名和服务器-IP-绑定" class="headerlink" title="（四）DNS 域名和服务器 IP 绑定"></a><strong>（四）DNS 域名和服务器 IP 绑定</strong></h3><p>在您的 DNS 域名提供商的管理界面中，将 ip 地址和域名进行绑定。此教程使用 <a href="https://sg.godaddy.com/zh">GoDaddy</a> 作为域名提供商，请读者根据实际情况进行设置。</p>
<p>GoDaddy 配置具体步骤：</p>
<ul>
<li>创建 A 记录： key 为@，value 为 DigitalOcean 为你分配的服务器 IP。 例如，此教程 IP 是 161.35.59.204， TTL 默认 1h.N</li>
<li>创建 CNAME 记录： key 为 www, value 为 @。 例如，此教程 IP 是 161.35.59.204, TTL 默认 1h.</li>
</ul>
<p>注意，域名和 IP 绑定后，由于网络 DNS 缓存机制，对应关系不会立马生效，实际生效时间快则数分钟，慢则数小时。</p>
<p>检验方法：</p>
<p>控制台，输入指令 “ping yourdomain.com”, 查看连接状态。如果连接返回来自服务器 IP 的网络包，则代表域名已成功匹配 IP。</p>
<h3 id="（五）Nginx-下载，进行反向代理配置，域名绑定"><a href="#（五）Nginx-下载，进行反向代理配置，域名绑定" class="headerlink" title="（五）Nginx 下载，进行反向代理配置，域名绑定"></a><strong>（五）Nginx 下载，进行反向代理配置，域名绑定</strong></h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 本教程使用Ubuntu18.04.3操作系统，请根据您OS版本进行Nginx安装。</span><br><span class="line"></span><br><span class="line">sudo apt update          # 更新软件库</span><br><span class="line">sudo apt install nginx      # 下载nginx</span><br><span class="line">sudo systemctl enable nginx # 配置nginx 作为开机服务</span><br></pre></td></tr></tbody></table></figure>

<p>当 nginx 下载后，在本地浏览器输入 <a href="http://161.35.59.204/">http://161.35.59.204:80/</a><br>看到 nginx 页面，表示 nginx 服务已经运行起来。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 打开nginx 默认配置文件</span><br><span class="line">sudo nano /etc/nginx/nginx.conf</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># nginx.conf 文件</span><br><span class="line"># 请确保http框中存在下面两句指令（ 一般默认存在，若不存在，则需手动添加 ）</span><br><span class="line"></span><br><span class="line">http{</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">include /etc/nginx/conf.d/*.conf;</span><br><span class="line">include /etc/nginx/sites-enabled/*;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>接着，进入 conf.d 文件夹中，为 helloworld 应用创建独立的配置文件，实际上，只要文件后缀是.conf，都会被 nginx 读取，但建议使用和项目名称相关联的命名方法，这里我们使用 com.helloworld.conf</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">touch /etc/nginx/conf.d/com.helloworld.conf  # 创建配置文件</span><br></pre></td></tr></tbody></table></figure>

<p>拷贝以下内容，保存文件并退出。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># com.helloworld.conf 文件</span><br><span class="line"></span><br><span class="line">server {</span><br><span class="line">       listen       80;</span><br><span class="line">       # 填写您在服务商购买的域名，本教程使用域名 demo.luqifu.tech</span><br><span class="line">       server_name   demo.luqifu.tech;</span><br><span class="line"></span><br><span class="line">    charset utf8;</span><br><span class="line"></span><br><span class="line">     location / {</span><br><span class="line"></span><br><span class="line">        # 映射到代理服务器，可以是ip加端口 或 url</span><br><span class="line">        proxy_pass       http://127.0.0.1:3000;</span><br><span class="line"></span><br><span class="line">        proxy_set_header Host      $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>接着，在控制台运行以下命令</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Nginx -t  # 修改后检查配置文件格式</span><br><span class="line">nginx -s reload  # 让nginx重新读取conf配置</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>现在，在浏览器中直接访问域名，就能直接访问 Helloworld 网页。</p>
<h3 id="（六）防火墙端口-80-443-端口配置"><a href="#（六）防火墙端口-80-443-端口配置" class="headerlink" title="（六）防火墙端口 80/443 端口配置"></a><strong>（六）防火墙端口 80/443 端口配置</strong></h3><p>但是，为了提高网站安全性，我们不希望用户通过 3000 端口访问网站。相反，应该在服务器端配置防火墙，只允许用户通过 80(HTTP)和 443（HTTPS）端口访问网站,</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 安装防火墙</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install ufw</span><br><span class="line"></span><br><span class="line"># 开启防火墙</span><br><span class="line">sudo ufw enable</span><br><span class="line"></span><br><span class="line"># 设置防火墙禁用所有端口</span><br><span class="line">sudo ufw default deny</span><br><span class="line"></span><br><span class="line"># 设置防火墙开启特定端口 ( ssh:22 | http:80 | https: 443 )</span><br><span class="line">sudo ufw allow ssh</span><br><span class="line">sudo ufw allow http</span><br><span class="line">sudo ufw allow https</span><br></pre></td></tr></tbody></table></figure>

<p>现在，浏览器只能通过 80 / 443 端口访问网站页面。<br>相信在你最喜爱的浏览器输入 <a href="http://demo.luqifu.tech/">http://demo.luqifu.tech</a> , 就能看到所部署的应用。<br>如果您希望为网站配置 HTTPS ( 443 ) 访问，请参考教程 <a href="/post/%E4%BD%BF%E7%94%A8let-s-encrypt%E5%9C%A8nginx%E4%B8%AD%E4%B8%BAnode%E5%BA%94%E7%94%A8%E6%B7%BB%E5%8A%A0https%E8%AE%BF%E9%97%AE.html" title="在Nginx中为Node应用添加HTTPS访问">在Nginx中为Node应用添加HTTPS访问</a>。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>至此，本教程结束。</p>
<p>这是我最近云端部署 Node 应用的一些心得，希望能帮到大家。</p>
<p>非常感谢。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Cloud Deployment</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Nginx</tag>
        <tag>DigitalOcean</tag>
        <tag>Cloud Deployment</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Let&#39;s Encrypt在Nginx中为Node应用添加HTTPS访问</title>
    <url>/post/%E4%BD%BF%E7%94%A8let-s-encrypt%E5%9C%A8nginx%E4%B8%AD%E4%B8%BAnode%E5%BA%94%E7%94%A8%E6%B7%BB%E5%8A%A0https%E8%AE%BF%E9%97%AE.html</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文讲述利用 Let’s Encrypt 生成 ssl 证书，将证书配置到 Nginx 反向代理，使 node.js 应用实现 https 访问。</p>
<h2 id="什么是-http-协议？"><a href="#什么是-http-协议？" class="headerlink" title="什么是 http 协议？"></a>什么是 http 协议？</h2><p>HTTP ( HyperText Transfer Protocol )协议, 又称超文本传输协议, 是一种用于分布式、协作式和超媒体信息系统的应用层协议。它是一种用于分布式、协作式和超媒体信息系统的应用层协议，也是万维网的数据通信的基础。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。通过 HTTP 或者 HTTPS 协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">来源: 维基百科</a></p>
<h2 id="http-和-https-的区别"><a href="#http-和-https-的区别" class="headerlink" title="http 和 https 的区别"></a>http 和 https 的区别</h2><p>HTTP 协议传输的数据都是明文传输的，因此使用 HTTP 协议视为安全性不足。为了保证这些隐私数据能加密传输，网景公司设计了 SSL（Secure Sockets Layer）协议用于对 HTTP 协议传输的数据进行加密，从而就诞生了 HTTPS。简单来说，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全。</p>
<blockquote>
<p>HTTP 协议使用 80 端口，HTTPS 协议使用 443 端口。</p>
</blockquote>
<h2 id="关于-SSL-安全证书"><a href="#关于-SSL-安全证书" class="headerlink" title="关于 SSL 安全证书"></a>关于 SSL 安全证书</h2><p>要为网站实现 HTTPS 访问，我们需要一张具有公信力的 CA （ Certificate Authority ）也就是证书授权中心颁发的 SSL 安全证书，并且将它部署到你的网站服务器上。此教程将会使用 <code>Let's Encrypt &amp; Certbot</code> 生成 SSL 安全证书。</p>
<blockquote>
<p>Let’s Encrypt 是一个于 2015 年三季度推出的数字证书认证机构，旨在以自动化流程消除手动创建和安装证书的复杂流程，为安全网站提供免费的传输层安全性协议（TLS）证书。</p>
</blockquote>
<h2 id="为网站添加-HTTPS-访问"><a href="#为网站添加-HTTPS-访问" class="headerlink" title="为网站添加 HTTPS 访问"></a>为网站添加 HTTPS 访问</h2><blockquote>
<p>这里，我将演示如何使用 Certbot 为 nginx 服务器添加 ssl 证书</p>
</blockquote>
<h3 id="一-访问-Certbot-官网-https-certbot-eff-org"><a href="#一-访问-Certbot-官网-https-certbot-eff-org" class="headerlink" title="(一) 访问 Certbot 官网 https://certbot.eff.org/"></a>(一) 访问 Certbot 官网 <a href="https://certbot.eff.org/">https://certbot.eff.org/</a></h3><p><img src="https://res.cloudinary.com/qifu1995/image/upload/v1597300452/tech_blog/certbot_ssl_node/step1.jpg"></p>
<hr>
<h3 id="二-Certbot-将基于您的-HTTP-server-类型-以及-服务器操作系统，为你选择合适的安装方案。"><a href="#二-Certbot-将基于您的-HTTP-server-类型-以及-服务器操作系统，为你选择合适的安装方案。" class="headerlink" title="(二) Certbot 将基于您的 HTTP server 类型 以及 服务器操作系统，为你选择合适的安装方案。"></a>(二) Certbot 将基于您的 HTTP server 类型 以及 服务器操作系统，为你选择合适的安装方案。</h3><p><img src="https://res.cloudinary.com/qifu1995/image/upload/v1597300859/tech_blog/certbot_ssl_node/step2.jpg"></p>
<hr>
<h3 id="（三）按照-Cerbot-官网给出的指令，为服务器安装并配置-ssl-证书。"><a href="#（三）按照-Cerbot-官网给出的指令，为服务器安装并配置-ssl-证书。" class="headerlink" title="（三）按照 Cerbot 官网给出的指令，为服务器安装并配置 ssl 证书。"></a>（三）按照 Cerbot 官网给出的指令，为服务器安装并配置 ssl 证书。</h3><blockquote>
<p><code>由于不同系统下，certbot 配置 ssl 证书方式不同。请务必根据 certbot 给出的指令执行。</code><br>本教程是在 <strong>ubuntu18.04.3</strong> 版本下使用 <strong>nginx</strong> 服务器，因此 Certbot 给出了下列指令:</p>
</blockquote>
<h4 id="1-SSH-远程登录到网站服务器"><a href="#1-SSH-远程登录到网站服务器" class="headerlink" title="1. SSH 远程登录到网站服务器"></a>1. SSH 远程登录到网站服务器</h4><p>使用 SSH 登录到部署网站的服务器，并且登录用户必须具有 sudo 权限。</p>
<h4 id="2-添加-Certbot-PPA"><a href="#2-添加-Certbot-PPA" class="headerlink" title="2. 添加 Certbot PPA"></a>2. 添加 Certbot PPA</h4><p>在服务器上添加 Certbot PPA 到包列表，执行下列操作:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install software-properties-common</span><br><span class="line">sudo add-apt-repository universe</span><br><span class="line">sudo add-apt-repository ppa:certbot/certbot</span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-安装-Certbot"><a href="#3-安装-Certbot" class="headerlink" title="3. 安装 Certbot"></a>3. 安装 Certbot</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt-get install certbot python3-certbot-nginx</span><br></pre></td></tr></tbody></table></figure>

<h4 id="4-配置-SSL-证书到-nginx-服务器上"><a href="#4-配置-SSL-证书到-nginx-服务器上" class="headerlink" title="4. 配置 SSL 证书到 nginx 服务器上"></a>4. 配置 SSL 证书到 nginx 服务器上</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sudo certbot --nginx</span><br></pre></td></tr></tbody></table></figure>

<h4 id="5-检查证书自动更新功能"><a href="#5-检查证书自动更新功能" class="headerlink" title="5. 检查证书自动更新功能"></a>5. 检查证书自动更新功能</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># certbot生成的ssl证书，有效期为90天</span><br><span class="line"># 我们需要定期手动更新证书; 或者使用Unix系统下的定时任务工具cron定期执行</span><br><span class="line"></span><br><span class="line">sudo certbot renew --dry-run</span><br></pre></td></tr></tbody></table></figure>

<h3 id="（四）-使用-https-访问您的网站"><a href="#（四）-使用-https-访问您的网站" class="headerlink" title="（四） 使用 https 访问您的网站"></a>（四） 使用 https 访问您的网站</h3><p>恭喜你，你已经可以使用 <a href="https://yourwebsite.com/">https://yourwebsite.com/</a> 访问您的网站 !</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Cloud Deployment</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>Cloud Deployment</tag>
        <tag>SSL</tag>
        <tag>HTTP &amp; HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH公钥创建教程</title>
    <url>/post/ssh%E5%85%AC%E9%92%A5%E5%88%9B%E5%BB%BA%E6%95%99%E7%A8%8B.html</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文主要讲述如何使用 ssh-keygen 命令创建属于您的公私钥对。</p>
<h2 id="为什么需要-SSH-Keys"><a href="#为什么需要-SSH-Keys" class="headerlink" title="为什么需要 SSH Keys ?"></a>为什么需要 SSH Keys ?</h2><p>在 SSH 协议出现之前，我们常使用比如 telnent, ftp 这类型应用层协议进行客户端与服务器端的信息交互。然而，这些协议并不安全，这是因为他们是明文传输客户端与服务端的身份验证信息，例如用户名和密码。也就意味着用户更容易受到臭名昭著的 “中间人攻击 ( Man-in-the-middle attack )”。SSH 协议为了确保信息的安全传输，从连接发起到完成各阶段的各个点 SSH 协议采用了许多不同类型的数据加密技术，包括可逆的对称加密，非对称加密以及不可逆的哈希散列。因此，我们认为 SSH 协议更加安全可靠。</p>
<h2 id="什么是-ssh-keygen"><a href="#什么是-ssh-keygen" class="headerlink" title="什么是 ssh-keygen ?"></a>什么是 ssh-keygen ?</h2><p>ssh-keygen 是 Unix 和类 Unix 计算机系统上的安全外壳（SSH）协议套件的标准组件，用于通过使用各种加密技术在不安全的网络上建立远程计算机之间的安全 shell 会话。<br>我们可以使用 ssh-keygen 生成，管理和转换身份验证密钥。本教程将会讲述使用 <code>ssh-keygen</code> 工具生成一对 <code>public key (公钥)</code> 和 <code>private key (私钥)</code>。</p>
<ul>
<li><code>公钥一般存放于支持 SSH 协议的服务器中，如云服务器，git远程仓库。</code></li>
<li><code>私钥则保存于客户端，如用户电脑。切不可外泄，因为它是服务端验证客户端身份的令牌。</code></li>
</ul>
<h2 id="SSH-key-创建流程"><a href="#SSH-key-创建流程" class="headerlink" title="SSH key 创建流程"></a>SSH key 创建流程</h2><h3 id="（一）首先检查-ssh-client-是否已安装在系统中"><a href="#（一）首先检查-ssh-client-是否已安装在系统中" class="headerlink" title="（一）首先检查 ssh client 是否已安装在系统中"></a>（一）首先检查 ssh client 是否已安装在系统中</h3><p>打开本地控制台，输入 <code>ssh</code></p>
<p>如果看见下列提示选项，则代表 ssh 命令可用</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&gt; ssh</span><br><span class="line">usage: ssh [-46Yy][-b bind_interface]</span><br><span class="line">[-b bind_address][-c cipher_spec] [-D [bind_address:]port][-e log_file] [-e escape_char][-f configfile] [-I pkcs11][-i identity_file] [-J [user@]host[:port]][-l address]</span><br><span class="line">[-l login_name][-m mac_spec] [-O ctl_cmd][-o option] [-p port][-q query_option] [-R address][-s ctl_path] [-W host:port]-w local_tun[:remote_tun]] destination [command]</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<hr>
<p>如果 ssh 命令不可用，则按照下列指示安装 openssh 服务。</p>
<h6 id="对于-window-用户："><a href="#对于-window-用户：" class="headerlink" title="对于 window 用户："></a>对于 window 用户：</h6><ul>
<li>第一种方法： 进入 <code>设置</code>-<code>应用</code>-<code>应用和功能</code>-<code>管理可选功能</code>-<code>添加功能</code> - <code>安装 OpenSSH 服务器和客户端</code>，安装完成后重启电脑。</li>
<li>第二种方法：从<a href="https://gitforwindows.org/">Git 官网</a>下载 <code>git</code> 和 <code>git bash</code>，使用 git bash 自带的 ssh 服务。</li>
</ul>
<h6 id="对于-mac-Unix-用户："><a href="#对于-mac-Unix-用户：" class="headerlink" title="对于 mac / Unix 用户："></a>对于 mac / Unix 用户：</h6><ul>
<li>系统应该自带了 ssh 服务，我们可以直接使用 ssh-keygen 命令</li>
</ul>
<hr>
<h3 id="（二）ssh-服务安装后，创建密钥："><a href="#（二）ssh-服务安装后，创建密钥：" class="headerlink" title="（二）ssh 服务安装后，创建密钥："></a>（二）ssh 服务安装后，创建密钥：</h3><p>打开本地控制台，输入</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 指定 –t 选项 使用类型为rsa创建密钥对。</span><br><span class="line"></span><br><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></tbody></table></figure>

<p>密钥创建过程中，需要按下多次回车键, 即默认值创建。创建完成后，系统会将新创建的密钥对保存在用户的.ssh 目录下。例如：</p>
<ul>
<li>Window 用户：<code>C:\Users\{你的用户名}\\.ssh</code></li>
<li>Mac / Unix 用户： <code>~/.ssh</code></li>
</ul>
<p>进入<code>.ssh</code> 目录，就能看到刚刚创建的公钥文件<code>id_rsa.pub</code> 和 私钥文件<code>id_rsa</code>。<strong>切记，私钥文件不能外泄；公钥则根据实际需要，保存到带有 SSH server 的服务器中</strong>。</p>
<h2 id="（三）结语："><a href="#（三）结语：" class="headerlink" title="（三）结语："></a>（三）结语：</h2><p>恭喜你，你已经拥有了能用于加解密的公钥对！<br>至此，本教程结束。非常感谢。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Cloud Deployment</category>
      </categories>
      <tags>
        <tag>SSH</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>创建DigitalOcean服务器实例Droplet</title>
    <url>/post/%E5%88%9B%E5%BB%BAdigitalocean%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E4%BE%8Bdroplet.html</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文主要讲述如何使用 DigitalOcean 创建我们的云服务器 VPS。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>DigitalOcean 是一家建立于美国的云基础架构提供商，面向软件开发人员提供虚拟专用服务器（VPS）， 现在已经是全球第二大的网络寄存服务公司。VPS 价格相对合理,月费最低 5 美金起。</p>
<h2 id="注册账户"><a href="#注册账户" class="headerlink" title="注册账户"></a>注册账户</h2><p>登录 DigitalOcean 官网，并创建 DigitalOcean 账户：<br>链接：<a href="https://www.digitalocean.com/">https://www.digitalocean.com/</a></p>
<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><hr>
<h4 id="一-登录账户后-创建-new-project"><a href="#一-登录账户后-创建-new-project" class="headerlink" title="(一) 登录账户后, 创建 new project."></a>(一) 登录账户后, 创建 new project.</h4><p><img src="https://res.cloudinary.com/qifu1995/image/upload/v1597292830/tech_blog/DigitalOcean_Droplet_Create/step0.jpg"></p>
<hr>
<h4 id="二-填写您的项目名称，描述和用途。"><a href="#二-填写您的项目名称，描述和用途。" class="headerlink" title="(二) 填写您的项目名称，描述和用途。"></a>(二) 填写您的项目名称，描述和用途。</h4><p><img src="https://res.cloudinary.com/qifu1995/image/upload/v1597293188/tech_blog/DigitalOcean_Droplet_Create/step1.jpg"></p>
<hr>
<h4 id="三-项目创建后，需要为项目新创建一个-Droplet-（Droplet-就是一个-VPS-服务器实例）。"><a href="#三-项目创建后，需要为项目新创建一个-Droplet-（Droplet-就是一个-VPS-服务器实例）。" class="headerlink" title="(三) 项目创建后，需要为项目新创建一个 Droplet （Droplet 就是一个 VPS 服务器实例）。"></a>(三) 项目创建后，需要为项目新创建一个 Droplet （Droplet 就是一个 VPS 服务器实例）。</h4><p><img src="https://res.cloudinary.com/qifu1995/image/upload/v1597293188/tech_blog/DigitalOcean_Droplet_Create/step2.jpg"></p>
<hr>
<h4 id="四-选择-Droplet-服务器的云端配置。请根据您实际需要自行配置，本教程中使用-ubuntu18-04-3-LTS-版本。"><a href="#四-选择-Droplet-服务器的云端配置。请根据您实际需要自行配置，本教程中使用-ubuntu18-04-3-LTS-版本。" class="headerlink" title="(四) 选择 Droplet 服务器的云端配置。请根据您实际需要自行配置，本教程中使用 ubuntu18.04.3(LTS)版本。"></a>(四) 选择 Droplet 服务器的云端配置。请根据您实际需要自行配置，本教程中使用 ubuntu18.04.3(LTS)版本。</h4><p><img src="https://res.cloudinary.com/qifu1995/image/upload/v1597293188/tech_blog/DigitalOcean_Droplet_Create/step3.jpg"><br><img src="https://res.cloudinary.com/qifu1995/image/upload/v1597293188/tech_blog/DigitalOcean_Droplet_Create/step4.jpg"><br><img src="https://res.cloudinary.com/qifu1995/image/upload/v1597293188/tech_blog/DigitalOcean_Droplet_Create/step5.jpg"></p>
<p><img src="https://res.cloudinary.com/qifu1995/image/upload/v1597293188/tech_blog/DigitalOcean_Droplet_Create/step6.jpg"></p>
<hr>
<h4 id="五-建议选择添加-SSH-key。这将用于本机远程登录服务器。使用-SSH-keys-验证比传统的密码验证更加安全方便。"><a href="#五-建议选择添加-SSH-key。这将用于本机远程登录服务器。使用-SSH-keys-验证比传统的密码验证更加安全方便。" class="headerlink" title="(五) 建议选择添加 SSH key。这将用于本机远程登录服务器。使用 SSH keys 验证比传统的密码验证更加安全方便。"></a>(五) 建议选择添加 SSH key。这将用于本机远程登录服务器。使用 SSH keys 验证比传统的密码验证更加安全方便。</h4><blockquote>
<p>尚未拥有 SSH key 公私钥，请参考 <a href="/post/ssh%E5%85%AC%E9%92%A5%E5%88%9B%E5%BB%BA%E6%95%99%E7%A8%8B.html" title="SSH公钥创建">SSH公钥创建</a> 教程。</p>
</blockquote>
<p><img src="https://res.cloudinary.com/qifu1995/image/upload/v1597293188/tech_blog/DigitalOcean_Droplet_Create/step7.jpg"><br><img src="https://res.cloudinary.com/qifu1995/image/upload/v1597293188/tech_blog/DigitalOcean_Droplet_Create/step8.jpg"></p>
<hr>
<h4 id="六-自定义主机名，创建-Droplet"><a href="#六-自定义主机名，创建-Droplet" class="headerlink" title="(六) 自定义主机名，创建 Droplet"></a>(六) 自定义主机名，创建 Droplet</h4><p><img src="https://res.cloudinary.com/qifu1995/image/upload/v1597293188/tech_blog/DigitalOcean_Droplet_Create/step9.jpg"></p>
<hr>
<h4 id="七-创建完成后，获取-Droplet-的公网-IP"><a href="#七-创建完成后，获取-Droplet-的公网-IP" class="headerlink" title="(七) 创建完成后，获取 Droplet 的公网 IP"></a>(七) 创建完成后，获取 Droplet 的公网 IP</h4><p><img src="https://res.cloudinary.com/qifu1995/image/upload/v1597293188/tech_blog/DigitalOcean_Droplet_Create/step10.jpg"></p>
<hr>
<h4 id="八-检查云服务器是否激活"><a href="#八-检查云服务器是否激活" class="headerlink" title="(八) 检查云服务器是否激活"></a>(八) 检查云服务器是否激活</h4><p><img src="https://res.cloudinary.com/qifu1995/image/upload/v1597293188/tech_blog/DigitalOcean_Droplet_Create/step11.jpg"></p>
<hr>
<h4 id="九-恭喜你，你已经拥有了一台-DigitalOcean-的云端服务器。"><a href="#九-恭喜你，你已经拥有了一台-DigitalOcean-的云端服务器。" class="headerlink" title="(九) 恭喜你，你已经拥有了一台 DigitalOcean 的云端服务器。"></a>(九) 恭喜你，你已经拥有了一台 DigitalOcean 的云端服务器。</h4><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Cloud Deployment</category>
      </categories>
      <tags>
        <tag>DigitalOcean</tag>
        <tag>Cloud Deployment</tag>
        <tag>VPS</tag>
      </tags>
  </entry>
  <entry>
    <title>网页开发之跨域请求CORS的实现-下篇</title>
    <url>/post/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82cors%E7%9A%84%E5%AE%9E%E7%8E%B0-%E4%B8%8B%E7%AF%87.html</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>通过本教程，您将会了解如何解决网页开发中的跨域请求（CORS）中的冲突。<br>如果您不清楚什么是跨域请求和跨域冲突，建议请先阅读上一篇教程 <a href="/post/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%E4%B9%8B%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82cors-%E4%B8%8A%E7%AF%87.html" title="网页开发之什么是跨域请求 CORS (上篇)">网页开发之什么是跨域请求 CORS (上篇)</a> 。</p>
<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p>本文会从 <span style="border-bottom:1px solid yellow">开发模式</span> 和 <span style="border-bottom:1px solid yellow">生产模式</span> 下探讨跨域冲突的解决方案。</p>
<hr>
<h2 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h2><p>开发模式下的跨域冲突，往往是因为前后端分离开发所导致的。<br>一个实际场景是，网页开发者使用 webpack 或者 Vue,react 等前端框架进行页面开发，把前端页面服务器运行在 <code>localhost:8080</code> 端口上。而服务器开发者使用了 Node.js 或者 Java 语言搭建了后端服务器，运行在 <code>localhost:8081</code> 端口。前端和后端之间使用预先设定好的 API 接口进行数据传输。<span style="color:yellow">虽然前后端都在 localhost 下进行开发，可由于使用端口不一致，如果使用预定好的 API 接口交互，他们之间就产生了跨域冲突</span>。</p>
<p>想要解决开发模式下的跨域冲突很简单，如果使用的是 webpack 项目，只需要在 webpack 配置文件 webpack.config.js 中添加 <code>devServer（代理服务器）</code> 配置。项目开启后，原有的页面请求会先被转发到代理服务器 devServer，代理服务器重写 请求 URL，转发至目标服务器，实现跨域。</p>
<p>例如有这一场景：</p>
<ul>
<li>客户端网页：<a href="http://localhost:8080/index.html">http://localhost:8080/index.html</a></li>
<li>客户端代理服务器地址：<a href="http://localhost:8080/">http://localhost:8080/</a></li>
<li>目标请求 URL： <a href="http://localhost:3333/my-cors-request">http://localhost:3333/my-cors-request</a></li>
</ul>
<p>那么，我们在 index.html 编写前端 JS 请求代码实现如下</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 当前页面 URL： http://localhost:8080/index.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先把请求发送同一 8080 端口下的代理服务器</span></span><br><span class="line">xhr.open(‘GET, ‘http:<span class="comment">//localhost:8080/api/my-cors-request’, true);</span></span><br><span class="line"></span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>在 webpack.config.js 添加 devServer 配置如下</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 代理服务器截获 http://localhost:8080/api/my-cors-request 请求</span></span><br><span class="line"></span><br><span class="line">    devServer: {</span><br><span class="line">    	host: <span class="string">"localhost"</span>,</span><br><span class="line">    	port: <span class="number">8080</span>,</span><br><span class="line">    	proxy: {</span><br><span class="line">    	  <span class="string">'/api'</span>: {</span><br><span class="line">    		target: <span class="string">'http://localhost:3333'</span>, <span class="comment">// 目标服务器地址</span></span><br><span class="line">    		changeOrigin: <span class="literal">true</span>,</span><br><span class="line">    		pathRewrite: {</span><br><span class="line">    			<span class="string">'/api'</span>: <span class="string">''</span> <span class="comment">// 重写 URL，去掉"/api"前缀</span></span><br><span class="line">    			<span class="comment">// url 重写为 http://localhost:3333/my-cors-request</span></span><br><span class="line">    		}</span><br><span class="line">    	  }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="代理服务器实现跨域原理："><a href="#代理服务器实现跨域原理：" class="headerlink" title="代理服务器实现跨域原理："></a><span style="color:yellow">代理服务器实现跨域原理：</span></h3><p><code>其实跨域冲突的产生，是浏览器为了保护用户安全，默认禁止页面将请求发送到一个不同源的服务器，并直接获取数据。</code> 事实上，服务器端并不会拒绝一个跨域请求。</p>
<pre><code>要在开发过程实现跨域，我们只需要改变请求流程 A 替换成 B：
A. 前端页面 --&gt; 后端服务器 （跨域冲突）
B. 前端页面 --&gt; 前端代理服务器 --&gt;后端服务器 （无跨域冲突）</code></pre>
<span style="color:yellow">
开发模式下的跨域冲突的解决，实际上只是利用前端框架所自带的代理服务器，进行请求转发，巧妙地欺骗了浏览器的检查。可我们都知道，对于即将上线的项目（生产环境），最后都需要 `"build"` 构建打包的，而打包出来的资源都是一堆静态资源 html,css,js 文件, 而所谓的代理服务器，其实也就不存在了。因此，要从根本上解决跨域冲突，终究还是得在服务器端进行跨域设置。
</span>

<hr>
<h2 id="生产模式"><a href="#生产模式" class="headerlink" title="生产模式"></a>生产模式</h2><p>网站开发完成后，我们一般要把网站部署到云端服务器或者自建的服务器中。那么如何解决生产模式下的跨域冲突呢？首先，我们必须了解浏览器对跨域请求的两大分类，分别是 <code>简单请求</code> 和 <code>非简单请求</code> 。</p>
<blockquote>
<p>关于简单/非简单请求，可前往阅读上一篇教程 <a href="/post/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%E4%B9%8B%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82cors-%E4%B8%8A%E7%AF%87.html" title="网页开发之什么是跨域请求 CORS (上篇)">网页开发之什么是跨域请求 CORS (上篇)</a> 。</p>
</blockquote>
<h3 id="简单请求："><a href="#简单请求：" class="headerlink" title="简单请求："></a>简单请求：</h3><p>为了形象说明，我们将假设一个跨域情景。<br>假设目前有两个源 ：<code>www.domain-a.com</code> 和 <code>www.domain-b.com</code>, 我们在浏览器上打开了 <code>https://www.domain-a.com</code> 的页面，在该页面上编写 js 脚本给 <code>https://www.domain-b.com</code> 发送了一个 ajax 请求(跨域)。</p>
<p><span style="color:yellow">那么在这过程中，浏览器会如何实现一个简单的跨域请求呢？(划重点)</span></p>
<ol>
<li><p>首先，浏览器默认会在 domain-a 发送的 Request Header 中额外添加一个 <code>origin</code> 字段，如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">origin : https://www.domain-a.com</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>接着，服务器端 domain-b 接受来自 domain-a 请求，解析 request header 后, 获取到上述 <code>origin</code> 字段。 服务器知道请求是来自于 domain-a，然后判断其是否为可信域。如果可信，则会在响应头 response header 中添加 <code>Access-Control-Allow-Origin</code> 字段：</p>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: https://www.domain-a.com</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>最后，浏览器分析来自 domain B 响应头的 <code>Access-Control-Allow-Origin</code> 字段, 得知 domain B 允许 domain A 跨域访问，才会把响应体返回给客户端。假如没有发现上述 Access-Control-Allow-Origin 字段，浏览器则会报错，并且屏蔽响应 body。</p>
</li>
</ol>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 以 express.js 后端为例</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> trusted_domain = [<span class="string">"https://www.domain-a.com"</span>];</span><br><span class="line"></span><br><span class="line">app.all(<span class="string">'/your-request-url'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(trusted_domain.includes(req.headers.origin)){</span><br><span class="line">    	res.append(<span class="string">"Access-Control-Allow-Origin"</span>, req.headers.origin);</span><br><span class="line">    	res.send(<span class="string">"CORS 请求成功!"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">    	res.send(<span class="string">"CORS 请求失败!"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">});</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h3 id="非简单请求："><a href="#非简单请求：" class="headerlink" title="非简单请求："></a>非简单请求：</h3><p>非简单请求，一般是指有可能对服务器资源进行修改的请求，例如</p>
<ul>
<li>客户端参数类型 <code>content-type: application/json</code> 的请求</li>
<li>方法为<code>put</code>,<code>delete</code>的请求</li>
<li>自定义 Request header 的请求</li>
</ul>
<span style="color:orange">
因此，面对非简单请求，浏览器在处理上会更加谨慎。
在发送非简单请求前，浏览器会先发送一个预检请求(preflight)。预检请求其实就是浏览器在通知服务器，它将会发一个非简单请求，而且有可能修改服务器上的资源，确认服务器是否允许执行。预检请求通过了，浏览器才会发起真正的非简单请求。
</span>

<h4 id="（i）基于-content-type-application-json-的非简单请求："><a href="#（i）基于-content-type-application-json-的非简单请求：" class="headerlink" title="（i）基于 content-type:application/json 的非简单请求："></a><span style="color:yellow">（i）基于 content-type:application/json 的非简单请求：</span></h4><p>假设 domain A 这次发送了一个方法为 POST，content-type 为 application/json 的请求给 domain B，浏览器就会认为这是一个非简单请求。</p>
<ul>
<li><p>首先，浏览器发送一个 method 为<code>OPTION</code>的预检请求（preflight）到 domain B 的服务器，并且在请求头带上 <code>origin：domain A</code> 字段</p>
</li>
<li><p>接着，服务器 domain B 获取到预检请求的<code>origin</code>字段，判断请求来源 domain A 是否可信，如果可信，则会在 response header 上添加如下字段：</p>
<p><code>Access-Control-Allow-Origin: https://www.domain-a.com</code><br><code>Access-Control-Allow-Headers : content-type</code></p>
</li>
<li><p>然后，浏览器获取 response header, 得知预检 preflight 通过。</p>
</li>
<li><p>最后，浏览器执行真正的跨域请求。</p>
</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 以 express.js 后端为例</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> trusted_domain = [<span class="string">"https://www.domain-a.com"</span>];</span><br><span class="line"></span><br><span class="line">app.all(<span class="string">'/your-request-url'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(trusted_domain.includes(req.headers.origin)){</span><br><span class="line">    	res.append(<span class="string">"Access-Control-Allow-Origin"</span>, req.headers.origin);</span><br><span class="line">    	res.append(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"content-type"</span>);</span><br><span class="line">    	<span class="keyword">if</span>(req.method === <span class="string">"OPTIONS"</span>){</span><br><span class="line">    		res.sendStatus(<span class="number">200</span>)</span><br><span class="line">    	}</span><br><span class="line">    	res.send(<span class="string">"CORS 请求成功!"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">    	res.send(<span class="string">"CORS 请求失败!"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">});</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h4 id="（ii）-基于-method-为-PUT-DELETE-的非简单请求："><a href="#（ii）-基于-method-为-PUT-DELETE-的非简单请求：" class="headerlink" title="（ii） 基于 method 为 PUT / DELETE 的非简单请求："></a><span style="color:yellow">（ii） 基于 method 为 PUT / DELETE 的非简单请求：</span></h4><p>我们回到同样的情境中，假设 domain A 这次发送了方法为 PUT 或者 DELETE 的请求，浏览器也会认为这是一个非简单请求。</p>
<ul>
<li>浏览器仍会先发送预检请求</li>
<li>服务器判断通过预检请求来源，在反应头添加下列字段：<br><code>Access-Control-Allow-Origin: https://www.domain-a.com</code><br><code>Access-Control-Allow-Methods : POST,DELETE,PUT</code></li>
<li>然后，浏览器获取 response header, 得知预检 preflight 通过。</li>
<li>最后，浏览器执行真正的跨域请求。</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 以 express.js 后端为例</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> trusted_domain = [<span class="string">"https://www.domain-a.com"</span>];</span><br><span class="line"></span><br><span class="line">app.all(<span class="string">'/your-request-url'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(trusted_domain.includes(req.headers.origin)){</span><br><span class="line">    	res.append(<span class="string">"Access-Control-Allow-Origin"</span>, req.headers.origin);</span><br><span class="line">    	res.append(<span class="string">"Access-Control-Allow-Methods"</span>, <span class="string">"PUT,DELETE,POST,GET"</span>);</span><br><span class="line">    	<span class="keyword">if</span>(req.method === <span class="string">"OPTIONS"</span>){</span><br><span class="line">    		res.sendStatus(<span class="number">200</span>)</span><br><span class="line">    	}</span><br><span class="line">    	res.send(<span class="string">"CORS 请求成功!"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">    	res.send(<span class="string">"CORS 请求失败!"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">});</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h4 id="（iii）基于自定义-header-的非简单请求："><a href="#（iii）基于自定义-header-的非简单请求：" class="headerlink" title="（iii）基于自定义 header 的非简单请求："></a><span style="color:yellow">（iii）基于自定义 header 的非简单请求：</span></h4><p>非简单请求还有一种情况，就是 domain A 在其请求中自定义了 header。</p>
<ul>
<li>浏览器仍会先发送预检请求</li>
<li>服务器判断通过预检请求来源，在反应头添加下列字段：<br><code>Access-Control-Allow-Origin: https://www.domain-a.com</code><br><code>Access-Control-Allow-Headers : &lt;您自定义的header名称&gt;</code></li>
<li>然后，浏览器获取 response header, 得知预检 preflight 通过。</li>
<li>最后，浏览器执行真正的跨域请求。</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 以 express.js 后端为例</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> trusted_domain = [<span class="string">"https://www.domain-a.com"</span>];</span><br><span class="line"></span><br><span class="line">app.all(<span class="string">'/your-request-url'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(trusted_domain.includes(req.headers.origin)){</span><br><span class="line">    	res.append(<span class="string">"Access-Control-Allow-Origin"</span>, req.headers.origin);</span><br><span class="line">    	res.append(<span class="string">"Access-Control-Allow-Methods"</span>, <span class="string">"PUT,DELETE,POST,GET"</span>);</span><br><span class="line">    	res.append(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"&lt;您自定义的header名称&gt;"</span>);</span><br><span class="line">    	<span class="keyword">if</span>(req.method === <span class="string">"OPTIONS"</span>){</span><br><span class="line">    		res.sendStatus(<span class="number">200</span>)</span><br><span class="line">    	}</span><br><span class="line">    	res.send(<span class="string">"CORS 请求成功!"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">    	res.send(<span class="string">"CORS 请求失败!"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">});</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>当然，为了对 CORS 有进一步的操作，服务器还可以定义以下字段：</p>
<ul>
<li>Access-Control-Allow-Credentials：boolean（允许浏览器携带 COOKIES）</li>
<li>Access-Control-Max-Age: int（指定预检请求的有效时长，假如上一次的预检请求发生的时间点仍在有效时长内，则下一次非简单请求的发送不需要再次发送预检请求）</li>
</ul>
<h2 id="结语："><a href="#结语：" class="headerlink" title="结语："></a>结语：</h2><p>到这里为止，我们已经把简单与非简单的各类型请求的跨域情况做出了分析，并且给出了解决方案。也相信大家对 CORS 已经有了一个比较全面的了解。在日常开发中，我们离不开跨域请求，因此掌握好跨域请求，绝不是一两篇教程就能完成的，还是需要大家多练习，多写写代码，以加深印象。<br>到此为止，本教程已经结束<br>非常感谢大家。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>CORS</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>CORS</tag>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title>网页开发之什么是跨域请求CORS-上篇</title>
    <url>/post/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%E4%B9%8B%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82cors-%E4%B8%8A%E7%AF%87.html</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>通过本教程，您将会了解什么是跨域请求（CORS），跨域请求的原理，以及跨域请求的具体示例。</p>
<blockquote>
<p>下一篇教程, 将讨论 <a href="/post/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82cors%E7%9A%84%E5%AE%9E%E7%8E%B0-%E4%B8%8B%E7%AF%87.html" title="网页开发之跨域请求CORS的实现(下篇)">网页开发之跨域请求CORS的实现(下篇)</a> 。</p>
</blockquote>
<h2 id="一-什么是跨域请求？"><a href="#一-什么是跨域请求？" class="headerlink" title="( 一 ) 什么是跨域请求？"></a>( 一 ) 什么是跨域请求？</h2><p>当一个源希望与另一个源的服务器资源进行交互时，前者会发送一系列的 HTTP 请求（GET,POST,DELETE,UPDATE 等）给后者，我们把这类型的请求视为跨域请求。具体来讲，只要两个站点所使用的<code>域名</code>，<code>协议</code>，<code>端口</code>任意一个不相等，我们把它们之间的 http 请求视为跨域。</p>
<h2 id="二-跨域示例"><a href="#二-跨域示例" class="headerlink" title="( 二 ) 跨域示例"></a>( 二 ) 跨域示例</h2><ul>
<li>不同的域: https://<code>www.google.com</code> &amp; https://<code>www.baidu.com</code></li>
<li>不同协议: <code>http</code>://<a href="http://www.baidu.com/">www.baidu.com</a> &amp; <code>https</code>://<a href="http://www.baidu.com/">www.baidu.com</a></li>
<li>不同端口: localhost:<code>8080</code> &amp; localhost:<code>8081</code></li>
</ul>
<h2 id="三-浏览器跨域警告"><a href="#三-浏览器跨域警告" class="headerlink" title="( 三 ) 浏览器跨域警告"></a>( 三 ) 浏览器跨域警告</h2><p>相信很多前端开发的朋友都碰到过以下的警告信息：</p>
<p><img src="https://res.cloudinary.com/qifu1995/image/upload/v1597579606/tech_blog/cors/step8.jpg" alt="跨域冲突 1"><br><img src="https://res.cloudinary.com/qifu1995/image/upload/v1597579606/tech_blog/cors/step6.jpg" alt="跨域冲突 2"><br><img src="https://res.cloudinary.com/qifu1995/image/upload/v1597579606/tech_blog/cors/step7.jpg" alt="跨域冲突 3"></p>
<ul>
<li>这是因为在默认情况下，客户端（浏览器）会禁止客户端所有非法的跨域请求。例如，我们通过浏览器打开 <code>http://127.0.0.1:8080</code> 的页面，浏览器是不允许该页面下发送跨域的 ajax 请求，以获取 <code>http://127.0.0.1:8081</code> 服务器下的资源 。</li>
<li>但有一种例外，网页上通过 <code>img</code>, <code>link</code>, <code>script</code> 等外链标签获取到的外部资源，也是跨域请求。浏览器默认这一类跨域请求是可信的，并不会禁止。过去，许多开发者则是基于外链标签可跨域的原理，使用 <code>JSONP</code> 发送跨域请求的。</li>
</ul>
<hr>
<h2 id="四-为什么禁止非法的跨域请求？"><a href="#四-为什么禁止非法的跨域请求？" class="headerlink" title="( 四 )为什么禁止非法的跨域请求？"></a>( 四 )为什么禁止非法的跨域请求？</h2><p>我们可以想象一个场景。小明每月都定期往银行存入 5000 元的工资，并且所有的操作都是在银行的官方网站 <code>www.yin-hang.com（可信站点）</code> 上进行的。<br>于是有一天，眼红的小黑（攻击者）设计了一个用户界面和银行的官方网站 100%相似的网站，命名为 <code>www.ying-hang.com（恶意站点）</code> ，并且通过恶意邮件链接发送给小明。<br>月末，小明收到了小黑的邮件，误以为是官方银行的工作人员发送的，大意地点开了邮件中的恶意网址链接 <code>www.ying-hang.com （恶意站点）</code>。<span style="color:red;background:yellow">这里请注意，在此之前小黑已经在恶意站点上发送了一次跨域请求，从可信站点上获取到大量基础数据，现在不仅是用户界面，甚至是页面数据也和真站点完全一致了。</span>小明也没有多思考， 直接在恶意站点输入了用于登录官方网址的账号密码。此时, 小黑已经获取到了小明的验证信息，<span style="color:red;background:yellow">再次尝试从恶意站点往可信站点发送获取小明用户数据的跨域请求。</span> 如果浏览器再次允许这次跨域请求的执行，真站点则会给恶意网站返回小明的用户数据，小明更加信以为真，然后呢？ 然后就真的凉凉了。。。</p>
<blockquote>
<p><span class="github-emoji" style="font-size:1em;font-weight:bold;color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8">⚠</span> 因此，大多数浏览器出于对用户安全的角度考虑，都会禁止所有非法的跨域请求。</p>
</blockquote>
<hr>
<h2 id="五-跨域请求的具体类型"><a href="#五-跨域请求的具体类型" class="headerlink" title="( 五 ) 跨域请求的具体类型"></a>( 五 ) 跨域请求的具体类型</h2><p>浏览器将跨域请求（CORS）分为简单请求（simple request） 以及 非简单请求(non-simple request)。</p>
<h3 id="简单请求："><a href="#简单请求：" class="headerlink" title="简单请求："></a>简单请求：</h3><ol>
<li><p>请求方法为 <code>GET</code>，<code>HEAD</code>， <code>POST</code>任意一种</p>
</li>
<li><p>HTTP 头信息只包含以下字段：</p>
</li>
</ol>
<ul>
<li><p><code>Accept</code></p>
</li>
<li><p><code>Accept-Language</code></p>
</li>
<li><p><code>Content-Type</code></p>
</li>
<li><p><code>Content-Language</code></p>
</li>
<li><p><code>DPR</code></p>
</li>
<li><p><code>Downlink</code></p>
</li>
<li><p><code>Save-Data</code></p>
</li>
<li><p><code>Viewport-Width</code></p>
</li>
<li><p><code>Width</code><br>其中 Content-type 只能是 application/x-www-form-urlencoded、multipart/form-data、text/plain 其中之一。</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 简单请求的例子</span></span><br><span class="line"><span class="comment">// 当前页面 http://127.0.0.1:8080/index.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HTTP_CONFIG = { <span class="attr">method</span>: <span class="string">"GET"</span> };</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 Fetch 给 http://127.0.0.1:8081/" 发送跨域请求，方法 GET</span></span><br><span class="line">fetch(<span class="string">"http://127.0.0.1:8081/"</span>, HTTP_CONFIG)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>{</span><br><span class="line"><span class="keyword">return</span> response.json();</span><br><span class="line">})</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>{</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Response from SERVER_2 : "</span>, res);</span><br><span class="line">});</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

</li>
</ul>
<hr>
<h3 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求:"></a>非简单请求:</h3><p>下列三种情况都属于非简单请求：</p>
<ol>
<li><p>请求头的 content-type 为 application/json 的 POST 请求</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 非简单请求的例子</span></span><br><span class="line"><span class="comment">// 当前页面 http://127.0.0.1:8080/index.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HTTP_CONFIG = {</span><br><span class="line">method: <span class="string">"POST"</span>,</span><br><span class="line">headers: {</span><br><span class="line"><span class="string">"content-type"</span>: <span class="string">"application/json"</span>,</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 Fetch 给 http://127.0.0.1:8081/" 发送跨域请求</span></span><br><span class="line">fetch(<span class="string">"http://127.0.0.1:8081/"</span>, HTTP_CONFIG)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>{</span><br><span class="line"><span class="keyword">return</span> response.json();</span><br><span class="line">})</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>{</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Response from SERVER_2 : "</span>, res);</span><br><span class="line">});</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>方法为 PUT, DELETE 的请求</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 非简单请求的例子</span></span><br><span class="line"><span class="comment">// 当前页面 http://127.0.0.1:8080/index.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HTTP_CONFIG = {</span><br><span class="line">method: <span class="string">"PUT"</span> <span class="comment">// 这里方法可以替换成 “DELETE”</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 Fetch 给 http://127.0.0.1:8081/" 发送跨域请求，方法 PUT</span></span><br><span class="line">fetch(<span class="string">"http://127.0.0.1:8081/"</span>, HTTP_CONFIG)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>{</span><br><span class="line"><span class="keyword">return</span> response.json();</span><br><span class="line">})</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>{</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Response from SERVER_2 : "</span>, res);</span><br><span class="line">});</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>自定义的 HTTP Header 的请求</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 非简单请求的例子</span></span><br><span class="line"><span class="comment">// 当前页面 http://127.0.0.1:8080/index.html</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> HTTP_CONFIG = {</span><br><span class="line">    method: <span class="string">"POST"</span>,</span><br><span class="line">    headers: {</span><br><span class="line">        <span class="comment">//自定义header : "x-custom-header"</span></span><br><span class="line">    	<span class="string">"x-custom-header"</span>: <span class="string">"my-header"</span>,</span><br><span class="line">    }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 Fetch 给 http://127.0.0.1:8081/" 发送跨域请求</span></span><br><span class="line">    fetch(<span class="string">"http://127.0.0.1:8081/"</span>, HTTP_CONFIG)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> response.json();</span><br><span class="line">    })</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Response from SERVER_2 : "</span>, res);</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<hr>
<h2 id="六-结语"><a href="#六-结语" class="headerlink" title="( 六 )结语"></a>( 六 )结语</h2><p>那么，我们已经知道浏览器面对跨域请求时候，把请求划分成<code>简单</code>和<code>非简单</code>两种类型。可正如上文所讲，浏览器为了保护用户安全，默认禁止非法的跨域请求，以及抛出典型的“跨域冲突”警告。那如果我们告诉浏览器，它处理的是一个合法的跨域请求呢？跨域冲突的问题不就解决了吗？！</p>
<blockquote>
<p>我们将在接下来的文章 <a href="/post/%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82cors%E7%9A%84%E5%AE%9E%E7%8E%B0-%E4%B8%8B%E7%AF%87.html" title="网页开发之跨域请求CORS的实现(下篇)">网页开发之跨域请求CORS的实现(下篇)</a> 进一步讨论。</p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>CORS</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>CORS</tag>
        <tag>AJAX</tag>
      </tags>
  </entry>
</search>
